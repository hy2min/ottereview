package com.ssafy.ottereview.reviewcomment.service;

import com.ssafy.ottereview.account.repository.AccountRepository;
import com.ssafy.ottereview.ai.service.AiAudioProcessingService;
import com.ssafy.ottereview.common.exception.BusinessException;
import com.ssafy.ottereview.githubapp.client.GithubApiClient;
import com.ssafy.ottereview.review.entity.Review;
import com.ssafy.ottereview.review.exception.ReviewErrorCode;
import com.ssafy.ottereview.review.repository.ReviewRepository;
import com.ssafy.ottereview.review.service.ReviewGithubService;
import com.ssafy.ottereview.reviewcomment.dto.ReviewCommentCreateRequest;
import com.ssafy.ottereview.reviewcomment.dto.ReviewCommentReplyRequest;
import com.ssafy.ottereview.reviewcomment.dto.ReviewCommentResponse;
import com.ssafy.ottereview.reviewcomment.dto.ReviewCommentUpdateRequest;
import com.ssafy.ottereview.reviewcomment.dto.ReviewCommentWithRepliesResponse;
import com.ssafy.ottereview.reviewcomment.entity.ReviewComment;
import com.ssafy.ottereview.reviewcomment.exception.ReviewCommentErrorCode;
import com.ssafy.ottereview.reviewcomment.repository.ReviewCommentRepository;
import com.ssafy.ottereview.s3.service.S3ServiceImpl;
import com.ssafy.ottereview.user.entity.User;
import com.ssafy.ottereview.user.exception.UserErrorCode;
import com.ssafy.ottereview.user.repository.UserRepository;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionSynchronization;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.web.multipart.MultipartFile;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;
import reactor.util.function.Tuple2;

@Slf4j
@RequiredArgsConstructor
@Service
public class ReviewCommentServiceImpl implements ReviewCommentService {

    private static final String COMMENT_TEMPLATE = """
            **üëÄ Reviewer: @%s**
            %s
            """;
    private final ReviewCommentRepository reviewCommentRepository;
    private final UserRepository userRepository;
    private final ReviewRepository reviewRepository;
    private final ReviewGithubService reviewGithubService;
    private final AccountRepository accountRepository;
    private final S3ServiceImpl s3Service;
    private final AiAudioProcessingService aiAudioProcessingService;
    private final GithubApiClient githubApiClient;

    @Override
    @Transactional
    public List<ReviewCommentResponse> createComments(Long reviewId,
                                                      ReviewCommentCreateRequest request,
                                                      MultipartFile[] files,
                                                      Long userId) {

        log.info("ÎåìÍ∏Ä ÏùºÍ¥Ñ ÏûëÏÑ± ÏãúÏûë - Review: {}, User: {}, ÎåìÍ∏Ä Ïàò: {}, ÌååÏùº Ïàò: {}",
                reviewId, userId, request.getComments().size(),
                files != null ? files.length : 0);

        List<String> uploadedFileKeys = Collections.synchronizedList(new ArrayList<>());

        try {
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new BusinessException(UserErrorCode.USER_NOT_FOUND));
            Review review = reviewRepository.findById(reviewId)
                    .orElseThrow(() -> new BusinessException(ReviewErrorCode.REVIEW_NOT_FOUND));

            List<ReviewComment> comments = Flux.fromIterable(request.getComments())
                    .flatMap(item -> createCommentMono(item, files, user, review, uploadedFileKeys), 5)
                    .collectList()
                    .block(Duration.ofMinutes(10));

            List<ReviewComment> savedComments = reviewCommentRepository.saveAll(comments);

            log.info("ÎåìÍ∏Ä ÏùºÍ¥Ñ ÏûëÏÑ± ÏôÑÎ£å - ÏÉùÏÑ±Îêú ÎåìÍ∏Ä Ïàò: {}", savedComments.size());

            return savedComments.stream()
                    .map(ReviewCommentResponse::from)
                    .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("ÎåìÍ∏Ä ÏùºÍ¥Ñ ÏûëÏÑ± Ï§ë Ïò§Î•ò Î∞úÏÉù", e);
            cleanupUploadedFiles(uploadedFileKeys);
            throw new BusinessException(ReviewCommentErrorCode.REVIEW_COMMENT_CREATE_FAILED);
        }
    }

    private boolean hasFile(ReviewCommentCreateRequest.CommentItem item, MultipartFile[] files) {
        return item.getFileIndex() != null &&
                files != null &&
                item.getFileIndex() < files.length &&
                files[item.getFileIndex()] != null &&
                !files[item.getFileIndex()].isEmpty();
    }

    private Mono<ReviewComment> createCommentMono(ReviewCommentCreateRequest.CommentItem item,
                                                  MultipartFile[] files,
                                                  User user,
                                                  Review review,
                                                  List<String> uploadedFileKeys) {
        if (hasFile(item, files)) {
            MultipartFile file = files[item.getFileIndex()];
            return processFile(file, review.getId(), uploadedFileKeys)
                    .map(tuple -> buildComment(item, user, review, tuple.getT1(), tuple.getT2()));
        } else {
            return Mono.just(buildComment(item, user, review, item.getBody(), null));
        }
    }

    private Mono<Tuple2<String, String>> processFile(MultipartFile file,
                                                     Long referenceId,
                                                     List<String> uploadedFileKeys) {
        Mono<String> aiProcessing = aiAudioProcessingService.processAudioFile(file);
        Mono<String> s3Upload = Mono.fromCallable(() -> {
            String key = s3Service.uploadFile(file, referenceId);
            uploadedFileKeys.add(key);
            return key;
        }).subscribeOn(Schedulers.boundedElastic());

        return Mono.zip(aiProcessing, s3Upload);
    }

    private ReviewComment buildComment(ReviewCommentCreateRequest.CommentItem item,
                                       User user,
                                       Review review,
                                       String body,
                                       String recordKey) {
        return ReviewComment.builder()
                .user(user)
                .review(review)
                .path(item.getPath())
                .body(body)
                .recordKey(recordKey)
                .position(item.getPosition())
                .line(item.getLine())
                .startLine(item.getStartLine())
                .startSide(item.getStartSide())
                .side(item.getSide())
                .githubCreatedAt(LocalDateTime.now())
                .githubUpdatedAt(LocalDateTime.now())
                .build();
    }

    private void cleanupUploadedFiles(List<String> uploadedFileKeys) {
        if (!uploadedFileKeys.isEmpty()) {
            s3Service.cleanupUploadedFiles(uploadedFileKeys);
        }
    }

    @Override
    @Transactional
    public ReviewCommentResponse updateComment(Long commentId,
                                               ReviewCommentUpdateRequest commentUpdateRequest, Long userId, MultipartFile file) {
        ReviewComment existingComment = reviewCommentRepository.findById(commentId)
                .orElseThrow(() -> new BusinessException(ReviewCommentErrorCode.REVIEW_COMMENT_NOT_FOUND));

        if (!existingComment.getUser().getId().equals(userId)) {
            throw new BusinessException(ReviewCommentErrorCode.REVIEW_COMMENT_NOT_AUTHORIZED);
        }

        String oldRecordKey = existingComment.getRecordKey();
        List<String> uploadedFileKeys = Collections.synchronizedList(new ArrayList<>());

        try {
            Mono<ReviewComment> commentMono;

            // ÌååÏùºÏù¥ ÏûàÏúºÎ©¥ processFile ‚Üí buildComment
            if (file != null && !file.isEmpty()) {
                commentMono = processFile(file, commentId, uploadedFileKeys)
                        .map(tuple -> buildComment(
                                        ReviewCommentCreateRequest.CommentItem.builder()
                                                .path(existingComment.getPath())
                                                .position(existingComment.getPosition())
                                                .line(existingComment.getLine())
                                                .startLine(existingComment.getStartLine())
                                                .startSide(existingComment.getStartSide())
                                                .side(existingComment.getSide())
                                                .body(tuple.getT1())
                                                .build(),
                                        existingComment.getUser(),
                                        existingComment.getReview(),
                                        tuple.getT1(),
                                        tuple.getT2()
                                ).toBuilder()
                                        .id(existingComment.getId())
                                        .githubId(existingComment.getGithubId())
                                        .diffHunk(existingComment.getDiffHunk())
                                        .githubCreatedAt(existingComment.getGithubCreatedAt())
                                        .githubUpdatedAt(LocalDateTime.now())
                                        .build()
                        );
            } else {
                // ÌÖçÏä§Ìä∏Îßå ÏàòÏ†ï
                String body = commentUpdateRequest.getBody() != null
                        ? commentUpdateRequest.getBody()
                        : existingComment.getBody();

                commentMono = Mono.just(
                        existingComment.toBuilder()
                                .body(body)
                                .githubUpdatedAt(LocalDateTime.now())
                                .build()
                );
            }

            ReviewComment updated = commentMono.block(Duration.ofMinutes(2));
            reviewCommentRepository.save(updated);

            // GitHub ÎèôÍ∏∞Ìôî
            githubUpdateComment(updated, updated.getBody());

            // Í∏∞Ï°¥ ÌååÏùº ÏÇ≠Ï†ú (Î≥ÄÍ≤Ω Ïãú)
            if (file != null && !file.isEmpty()
                    && oldRecordKey != null
                    && !oldRecordKey.equals(updated.getRecordKey())) {
                s3Service.deleteFile(oldRecordKey);
            }

            return ReviewCommentResponse.from(updated);

        } catch (Exception e) {
            cleanupUploadedFiles(uploadedFileKeys);
            throw new BusinessException(ReviewCommentErrorCode.REVIEW_COMMENT_UPDATE_FAILED);
        }
    }

    private void githubUpdateComment(ReviewComment comment, String newBody) {
        try {
            String repoFullName = comment.getReview().getPullRequest().getRepo().getFullName();
            Long accountId = comment.getReview().getPullRequest().getRepo().getAccount().getId();

            Long installationId = accountRepository.findById(accountId)
                    .orElseThrow(() -> new RuntimeException("Account not found"))
                    .getInstallationId();

            reviewGithubService.updateReviewCommentOnGithub(
                    installationId,
                    repoFullName,
                    comment.getGithubId(),
                    newBody,
                    comment.getUser().getGithubUsername()
            );
        } catch (Exception e) {
            log.error("GitHub ÏΩîÎ©òÌä∏ ÎèôÍ∏∞Ìôî Ïã§Ìå®: commentId={}, message={}", comment.getId(), e.getMessage());
        }
    }

    @Override
    @Transactional
    public void deleteComment(Long commentId, Long userId) {
        ReviewComment comment = reviewCommentRepository.findById(commentId)
                .orElseThrow(() -> new IllegalArgumentException("Comment not found: " + commentId));

        // ÏûëÏÑ±Ïûê Í≤ÄÏ¶ù
        if (!comment.getUser().getId().equals(userId)) {
            throw new IllegalArgumentException("Î≥∏Ïù∏Ïù¥ ÏûëÏÑ±Ìïú ÎåìÍ∏ÄÎßå ÏÇ≠Ï†úÌï† Ïàò ÏûàÏäµÎãàÎã§.");
        }

        // Ïô∏Î∂Ä Î¶¨ÏÜåÏä§ Ï†ïÎ≥¥Îäî ÎØ∏Î¶¨ Ï†ÄÏû•
        String recordKey = comment.getRecordKey();
        Long githubId = comment.getGithubId();
        String repoFullName = comment.getReview().getPullRequest().getRepo().getFullName();
        Long accountId = comment.getReview().getPullRequest().getRepo().getAccount().getId();

        // DB ÏÇ≠Ï†ú (Ìä∏ÎûúÏû≠ÏÖò ÏïàÏóêÏÑú)
        reviewCommentRepository.deleteById(commentId);
        log.info("ÎåìÍ∏Ä DB ÏÇ≠Ï†ú ÏôÑÎ£å - CommentId: {}", commentId);

        // Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã Ïù¥ÌõÑ Ïô∏Î∂Ä Î¶¨ÏÜåÏä§ ÏÇ≠Ï†ú
        if (TransactionSynchronizationManager.isSynchronizationActive()) {
            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    // 1. S3 ÏÇ≠Ï†ú
                    if (recordKey != null && !recordKey.isEmpty()) {
                        try {
                            s3Service.deleteFile(recordKey);
                            log.info("S3 ÌååÏùº ÏÇ≠Ï†ú ÏôÑÎ£å - CommentId: {}, RecordKey: {}", commentId, recordKey);
                        } catch (Exception e) {
                            log.error("S3 ÌååÏùº ÏÇ≠Ï†ú Ïã§Ìå® - CommentId: {}, RecordKey: {}", commentId, recordKey, e);
                        }
                    }

                    // 2. GitHub ÏÇ≠Ï†ú
                    try {
                        Long installationId = accountRepository.findById(accountId)
                                .orElseThrow(() -> new RuntimeException("Account not found"))
                                .getInstallationId();

                        reviewGithubService.deleteReviewCommentOnGithub(installationId, repoFullName, githubId);
                        log.info("GitHub Î¶¨Î∑∞ ÏΩîÎ©òÌä∏ ÏÇ≠Ï†ú ÏôÑÎ£å - CommentId: {}, GithubId: {}", commentId, githubId);
                    } catch (Exception e) {
                        log.error("GitHub Î¶¨Î∑∞ ÏΩîÎ©òÌä∏ ÏÇ≠Ï†ú Ïã§Ìå® - GithubId: {}", githubId, e);
                    }
                }
            });
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReviewCommentResponse> getCommentsByReviewId(Long reviewId) {
        Review review = reviewRepository.findById(reviewId)
                .orElseThrow(() -> new IllegalArgumentException("Review not found: " + reviewId));

        List<ReviewComment> comments = reviewCommentRepository.findAllByReview(review);
        return comments.stream()
                .map(this::createResponseWithVoiceUrl)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public ReviewCommentResponse getCommentById(Long commentId) {
        ReviewComment comment = reviewCommentRepository.findById(commentId)
                .orElseThrow(() -> new IllegalArgumentException("Comment not found: " + commentId));
        return createResponseWithVoiceUrl(comment);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReviewCommentResponse> getCommentsByUserId(Long userId) {
        List<ReviewComment> comments = reviewCommentRepository.findAllByUserId(userId);
        return comments.stream()
                .map(this::createResponseWithVoiceUrl)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReviewCommentResponse> getCommentsByReviewIdAndPath(Long reviewId, String path) {
        Review review = reviewRepository.findById(reviewId)
                .orElseThrow(() -> new IllegalArgumentException("Review not found: " + reviewId));

        List<ReviewComment> comments = reviewCommentRepository.findAllByReviewAndPath(review, path);
        return comments.stream()
                .map(this::createResponseWithVoiceUrl)
                .collect(Collectors.toList());
    }

    /**
     * ReviewCommentÎ•º ReviewCommentResponseÎ°ú Î≥ÄÌôòÌïòÎ©¥ÏÑú recordKeyÍ∞Ä ÏûàÏúºÎ©¥ Pre-signed URLÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
     */
    private ReviewCommentResponse createResponseWithVoiceUrl(ReviewComment comment) {
        ReviewCommentResponse response = ReviewCommentResponse.from(comment);

        // recordKeyÍ∞Ä ÏûàÏúºÎ©¥ Pre-signed URL ÏÉùÏÑ±
        if (comment.getRecordKey() != null && !comment.getRecordKey().trim().isEmpty()) {
            try {
                String voiceUrl = s3Service.generatePresignedUrl(comment.getRecordKey(), 60); // 60Î∂Ñ Ïú†Ìö®
                return response.toBuilder()
                        .voiceFileUrl(voiceUrl)
                        .build();
            } catch (Exception e) {
                log.warn("ÏùåÏÑ± ÌååÏùº URL ÏÉùÏÑ± Ïã§Ìå® - commentId: {}, recordKey: {}, error: {}",
                        comment.getId(), comment.getRecordKey(), e.getMessage());
                // URL ÏÉùÏÑ± Ïã§Ìå®Ìï¥ÎèÑ ÏùëÎãµÏùÄ Î∞òÌôò
            }
        }

        return response;
    }

    /**
     * ÌÅ¥Î°úÎìú ÏΩîÎìú
     */


    @Override
    @Transactional
    public ReviewCommentResponse createReply(ReviewCommentReplyRequest request, Long userId) {
        // 1. Î∂ÄÎ™® ÎåìÍ∏Ä Ï°¥Ïû¨ ÌôïÏù∏
        ReviewComment parentComment = reviewCommentRepository.findById(request.getParentCommentId())
                .orElseThrow(() -> new BusinessException(ReviewCommentErrorCode.REVIEW_COMMENT_NOT_FOUND));

        // 2. ÏûëÏÑ±Ïûê Ï°∞Ìöå
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new BusinessException(UserErrorCode.USER_NOT_FOUND));

        // 3. ÎãµÍ∏Ä ÏÉùÏÑ±
        ReviewComment reply = ReviewComment.builder()
                .user(user)
                .review(parentComment.getReview())
                .path(parentComment.getPath())
                .body(request.getBody())
                .parentComment(parentComment)
                .build();

        ReviewComment savedReply = reviewCommentRepository.save(reply);

        // 4. GitHubÏóê ÎãµÍ∏Ä ÏÉùÏÑ±
        try {
            createReplyOnGithub(savedReply, parentComment, user.getGithubUsername());
        } catch (Exception e) {
            log.error("GitHub ÎãµÍ∏Ä ÏÉùÏÑ± Ïã§Ìå® - ÎãµÍ∏Ä ID: {}, Î∂ÄÎ™® ÎåìÍ∏Ä ID: {}, Ïò§Î•ò: {}", 
                    savedReply.getId(), parentComment.getId(), e.getMessage());
        }

        return ReviewCommentResponse.from(savedReply);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReviewCommentWithRepliesResponse> getCommentsWithReplies(Long reviewId) {
        Review review = reviewRepository.findById(reviewId)
                .orElseThrow(() -> new BusinessException(ReviewErrorCode.REVIEW_NOT_FOUND));

        // ÏµúÏÉÅÏúÑ ÎåìÍ∏ÄÎì§Îßå Ï°∞Ìöå
        List<ReviewComment> parentComments = reviewCommentRepository.findAllByReview(review)
                .stream()
                .filter(comment -> comment.getParentComment() == null)
                .collect(Collectors.toList());

        // Î™®Îì† ÎãµÍ∏ÄÎì§ÏùÑ Ï°∞ÌöåÌïòÍ≥† Î∂ÄÎ™® ÎåìÍ∏ÄÎ≥ÑÎ°ú Í∑∏Î£πÌïë
        List<ReviewComment> allReplies = reviewCommentRepository.findAllByReview(review)
                .stream()
                .filter(comment -> comment.getParentComment() != null)
                .collect(Collectors.toList());

        Map<Long, List<ReviewComment>> repliesByParentId = allReplies.stream()
                .collect(Collectors.groupingBy(reply -> reply.getParentComment().getId()));

        // Í≥ÑÏ∏µ Íµ¨Ï°∞Î°ú Î≥ÄÌôò
        return parentComments.stream()
                .map(parent -> {
                    ReviewCommentWithRepliesResponse response = createResponseWithVoiceUrlForReplies(parent);
                    List<ReviewComment> replies = repliesByParentId.getOrDefault(parent.getId(), Collections.emptyList());
                    List<ReviewCommentWithRepliesResponse> replyResponses = replies.stream()
                            .map(this::createResponseWithVoiceUrlForReplies)
                            .collect(Collectors.toList());
                    return response.toBuilder().replies(replyResponses).build();
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReviewCommentResponse> getRepliesByParentId(Long parentCommentId) {
        List<ReviewComment> replies = reviewCommentRepository.findAllByParentCommentId(parentCommentId);

        if(replies.isEmpty()) {
            throw new BusinessException(ReviewCommentErrorCode.REVIEW_COMMENT_RETRIEVE_FAILED);
        }

        return replies.stream()
                .map(this::createResponseWithVoiceUrl)
                .collect(Collectors.toList());
    }

    private void createReplyOnGithub(ReviewComment reply, ReviewComment parentComment, String githubUsername) {
        if (parentComment.getGithubId() == null) {
            log.warn("Î∂ÄÎ™® ÎåìÍ∏ÄÏóê GitHub IDÍ∞Ä ÏóÜÏñ¥ GitHub ÎãµÍ∏ÄÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§ - Î∂ÄÎ™® ÎåìÍ∏Ä ID: {}", parentComment.getId());
            return;
        }

        try {
            String repoFullName = reply.getReview().getPullRequest().getRepo().getFullName();
            Long installationId = reply.getReview().getPullRequest().getRepo().getAccount().getInstallationId();

            var githubComment = githubApiClient.createReviewCommentReply(
                    installationId,
                    repoFullName,
                    reply.getReview().getPullRequest().getGithubPrNumber(),
                    parentComment.getGithubId(), // Î∂ÄÎ™® ÎåìÍ∏ÄÏùò GitHub ID
                    COMMENT_TEMPLATE.formatted(githubUsername, reply.getBody())
            );

            // GitHub IDÏôÄ in_reply_to ID ÏóÖÎç∞Ïù¥Ìä∏
            reply = reply.toBuilder()
                    .githubId(githubComment.getId())
                    .githubInReplyToId(parentComment.getGithubId())
                    .line(githubComment.getLine())
                    .startLine(githubComment.getStartLine())
                    .startSide(githubComment.getStartSide().toString())
                    .side(githubComment.getSide().toString())
                    .position(githubComment.getPosition())
                    .diffHunk(githubComment.getDiffHunk())
                    .build();
            
            reviewCommentRepository.save(reply);

            log.info("GitHub ÎãµÍ∏Ä ÏÉùÏÑ± ÏÑ±Í≥µ - ÎãµÍ∏Ä ID: {}, GitHub ÎåìÍ∏Ä ID: {}", reply.getId(), githubComment.getId());

        } catch (Exception e) {
            log.error("GitHub ÎãµÍ∏Ä ÏÉùÏÑ± Ïã§Ìå®", e);
            throw new BusinessException(ReviewCommentErrorCode.REVIEW_COMMENT_CREATE_FAILED);
        }
    }

    private ReviewCommentWithRepliesResponse createResponseWithVoiceUrlForReplies(ReviewComment comment) {
        ReviewCommentWithRepliesResponse response = ReviewCommentWithRepliesResponse.from(comment);

        // recordKeyÍ∞Ä ÏûàÏúºÎ©¥ Pre-signed URL ÏÉùÏÑ±
        if (comment.getRecordKey() != null && !comment.getRecordKey().trim().isEmpty()) {
            try {
                String voiceUrl = s3Service.generatePresignedUrl(comment.getRecordKey(), 60);
                return response.toBuilder()
                        .voiceFileUrl(voiceUrl)
                        .build();
            } catch (Exception e) {
                log.warn("ÏùåÏÑ± ÌååÏùº URL ÏÉùÏÑ± Ïã§Ìå® - commentId: {}, recordKey: {}, error: {}",
                        comment.getId(), comment.getRecordKey(), e.getMessage());
            }
        }

        return response;
    }
}
